
<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>浅谈动态规划（三）——找到最优时的解 | Frank</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前两次动态规划的博客中，介绍了动态规划最基础的两个特点以及列举了几个我在做lintcode中遇到的接触动态规划初期相对比较适合做的题目。这次结合几道题目来总结一下动态规划的另一个特点——找到最优时的解。同样，还是以题目来说明。## 1.Minimum Adjustment Cost题目描述：Given an integer array, adjust each integers so that t">
<meta property="og:type" content="article">
<meta property="og:title" content="浅谈动态规划（三）——找到最优时的解">
<meta property="og:url" content="http://skills.frankge.me/getting-start-to-dynamic-programming-part3-find-the-optimal-solution/index.html">
<meta property="og:site_name" content="Frank">
<meta property="og:description" content="前两次动态规划的博客中，介绍了动态规划最基础的两个特点以及列举了几个我在做lintcode中遇到的接触动态规划初期相对比较适合做的题目。这次结合几道题目来总结一下动态规划的另一个特点——找到最优时的解。同样，还是以题目来说明。## 1.Minimum Adjustment Cost题目描述：Given an integer array, adjust each integers so that t">
<meta property="og:image" content="http://blog.frankge.me/wp-content/uploads/2016/12/getting-start-to-dynamic-programming-part3-find-the-optimal-solution_001-768x538.png">
<meta property="og:updated_time" content="2016-12-07T10:35:19.375Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="浅谈动态规划（三）——找到最优时的解">
<meta name="twitter:description" content="前两次动态规划的博客中，介绍了动态规划最基础的两个特点以及列举了几个我在做lintcode中遇到的接触动态规划初期相对比较适合做的题目。这次结合几道题目来总结一下动态规划的另一个特点——找到最优时的解。同样，还是以题目来说明。## 1.Minimum Adjustment Cost题目描述：Given an integer array, adjust each integers so that t">
<meta name="twitter:image" content="http://blog.frankge.me/wp-content/uploads/2016/12/getting-start-to-dynamic-programming-part3-find-the-optimal-solution_001-768x538.png">
  
    <link rel="alternative" href="/atom.xml" title="Frank" type="application/atom+xml">
  
  
    <link href="/favicon.ico" rel="icon" type="image/x-ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]--><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
</head>
<body>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Frank</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">去探索更大的世界</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="skills.frankge.me">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-getting-start-to-dynamic-programming-part3-find-the-optimal-solution" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/getting-start-to-dynamic-programming-part3-find-the-optimal-solution/" class="article-date">
  <time datetime="2016-12-04T12:23:26.000Z" itemprop="datePublished">2016-12-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/编程学习/">编程学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      浅谈动态规划（三）——找到最优时的解
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p style="text-align: justify;">前两次动态规划的博客中，介绍了动态规划最基础的两个特点以及列举了几个我在做lintcode中遇到的接触动态规划初期相对比较适合做的题目。这次结合几道题目来总结一下动态规划的另一个特点——找到最优时的解。<br><br>同样，还是以题目来说明。<br><br>## 1.<a href="http://www.lintcode.com/en/problem/minimum-adjustment-cost/" target="_blank" rel="external">Minimum Adjustment Cost</a><br><br>题目描述：<br><br>Given an integer array, adjust each integers so that the difference of every adjacent integers are not greater than a given number target.If the array before adjustment is <code>A</code>, the array after adjustment is <code>B</code>, you should minimize the sum of <code>|A[i]-B[i]|</code><br><br>Notice: You can assume each number in the array is a positive integer and not greater than <code>100</code>.<br><br>Example: Given <code>[1,4,2,3]</code> and <code>target = 1</code>, one of the solutions is <code>[2,3,2,3]</code>, the adjustment cost is <code>2</code> and it’s minimal.<br><br>题目给出了一个数组<code>A</code>，并且给出了一个目标数字<code>target</code>。要求调整数组中每个位置的数字得到数组B，使得数组B中相邻元素的差值的绝对值小于等于<code>target</code>，且<code>sum（|A[i] - B[i]|）</code>最小。求得到最终结果时每个位置调整的和最小为多少。<br><br>题目只要求找出最小的调整开销的和，我这里再加一问：在调整和为最小值时，找出一个可能的数组<code>B</code>。<br><br>先来解决lintcode要求的问题。<br><br>Minimum Adjustment Cost题解:<br><br>我们应该能够想通一个问题，调整后的每个位置的数字都是在A数组中出现的最小值与最大值之间的数字。假设最小值是<code>minVal</code>，最大值是<code>maxVal</code>，所以数组B的每个位置上可选择的数字的个数为<code>count = maxVal - minVal + 1</code>。<br><br>构造一个二维数组<code>cost[n+1][count]</code>，<code>n</code>表示数组<code>A</code>中的个数。<code>cost[loop][j]（0 &lt;= loop &lt;= n, minVal &lt;= j &lt;= maxVal）</code>表示<code>B</code>数组中第<code>loop</code>个位置上（此时<code>B</code>的下标为<code>loop-1</code>）调整为数字j时的调整总和（包括<code>loop</code>之前的所有位置的调整的和）。那么当调整下一个位置<code>loop+1</code>时，调整为数字i的调整总和为<code>cost[loop+1][i] = min(cost[loop][j] + |i - A[loop]|),|i - j| &lt;= target</code>。这里<code>j</code>是上一个位置时调整的结果，因为有限制条件相邻的两个元素差的绝对值小于<code>target</code>，所以要用到上一个位置的数组；<code>|i - A[i]|</code>是此位置（数组<code>B</code>中第<code>loop+1</code>个数字，下标为<code>loop</code>）调整为i时调整的代价。最后的结果是<code>cost[n][i]（minVal &lt;= i &lt;= maxVal]）</code>中最小的值。<br><br>可能我的表述不太清楚，加注释的代码可能表达的更清楚些：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinAdjustmentCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> target)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n = A.size();</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span> || n == <span class="number">1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> minVal = INT_MAX; <span class="comment">// 记录数组中最小值</span></div><div class="line">	<span class="keyword">int</span> maxVal = INT_MIN; <span class="comment">// 记录数组中最大值</span></div><div class="line">			</div><div class="line">	<span class="keyword">int</span> loop, i, j;</div><div class="line">	</div><div class="line">	<span class="comment">// 找出数组A中出现的最小值和最大值</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span> (A[i] &gt; maxVal)</div><div class="line">			maxVal = A[i];</div><div class="line">		<span class="keyword">if</span> (A[i] &lt; minVal)</div><div class="line">			minVal = A[i];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">int</span> count = maxVal - minVal + <span class="number">1</span>; <span class="comment">// 每次需要动态规划的个数</span></div><div class="line">	<span class="comment">// 辅助数组。记录每个位置上B调整为不同数字的最小开销。</span></div><div class="line">	<span class="comment">// 即，当B数组第loop个数字调整为i的时候的最小开销为cost[loop][i]</span></div><div class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; cost(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(count, INT_MAX)); </div><div class="line">	<span class="comment">// 初始化</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</div><div class="line">		cost[<span class="number">0</span>][i] = <span class="number">0</span>; </div><div class="line"></div><div class="line">	<span class="comment">// 动态规划步骤</span></div><div class="line">	<span class="keyword">for</span> (loop = <span class="number">1</span>; loop &lt;= n; loop++)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">// 找出数组B中，第loop个位置（下标为loop-1），选择数字i的最小调整代价</span></div><div class="line">		<span class="comment">// 即，找出cost[loop][i]。它记录了到loop位置时，调整为i数字的最小开销</span></div><div class="line">		<span class="keyword">for</span> (i = minVal; i &lt;= maxVal; i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">for</span> (j = minVal; j &lt;= maxVal; j++)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span> (<span class="built_in">abs</span>(i-j) &lt;= target)</div><div class="line">				&#123;</div><div class="line">					<span class="keyword">int</span> temp = cost[loop<span class="number">-1</span>][j-minVal] + <span class="built_in">abs</span>(i-A[loop<span class="number">-1</span>]); <span class="comment">// 当第loop-1个数字选择j时，第loop个数字选择（调整到）i时的改变量</span></div><div class="line">					<span class="keyword">if</span> (temp &lt; cost[loop][i-minVal]) <span class="comment">// 找出最小的调整代价</span></div><div class="line">						cost[loop][i-minVal] = temp;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 找出最后一个位置改变结束时最小的改变代价</span></div><div class="line">	<span class="keyword">int</span> minCost = INT_MAX;</div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</div><div class="line">		minCost = min(cost[n][i], minCost);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> minCost;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>我们发现，在每次比较找出最小开销的时候，可以在加一个辅助数组<code>record[n+1][count]</code>,记录每个位置时最小调整开销时选择的数字，最后得到了完整的cost列表之后，<code>cost[n][i]（minVal &lt;= i &lt;= maxVal]）</code>中最小时i的值就是<code>B[n-1]</code>中的值，然后<code>record[n][i]</code>中记录的即使上一个位置对应的<code>B</code>中的值，一次类推，便能找到<code>B</code>数组一个可能的结果。同样，看代码可能更清楚点：<br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实现了记录每次选择数字的功能</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MinAdjustmentCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> target)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n = A.size();</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span> || n == <span class="number">1</span>)</div><div class="line">		<span class="keyword">return</span>;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> minVal = INT_MAX; <span class="comment">// 记录数组中最小值</span></div><div class="line">	<span class="keyword">int</span> maxVal = INT_MIN; <span class="comment">// 记录数组中最大值</span></div><div class="line">			</div><div class="line">	<span class="keyword">int</span> loop, i, j;</div><div class="line">			</div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span> (A[i] &gt; maxVal)</div><div class="line">			maxVal = A[i];</div><div class="line">		<span class="keyword">if</span> (A[i] &lt; minVal)</div><div class="line">			minVal = A[i];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">int</span> count = maxVal - minVal + <span class="number">1</span>; <span class="comment">// 每次需要动态规划的个数</span></div><div class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; cost(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(count, INT_MAX)); <span class="comment">// 辅助数组</span></div><div class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; record(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(count, <span class="number">0</span>));</div><div class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B(n);</div><div class="line">	<span class="comment">// 初始化</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</div><div class="line">		cost[<span class="number">0</span>][i] = <span class="number">0</span>; </div><div class="line"></div><div class="line">	<span class="comment">// 动态规划步骤</span></div><div class="line">	<span class="keyword">for</span> (loop = <span class="number">1</span>; loop &lt;= n; loop++)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">// 找出第loop个位置，选择数字i的最小调整代价</span></div><div class="line">		<span class="keyword">for</span> (i = minVal; i &lt;= maxVal; i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">for</span> (j = minVal; j &lt;= maxVal; j++)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span> (<span class="built_in">abs</span>(i-j) &lt;= target)</div><div class="line">				&#123;</div><div class="line">					<span class="keyword">int</span> temp = cost[loop<span class="number">-1</span>][j-minVal] + <span class="built_in">abs</span>(i-A[loop<span class="number">-1</span>]); <span class="comment">// 当第loop-1个数字选择j时，第loop个数字选择（调整到）i时的改变量</span></div><div class="line">					<span class="keyword">if</span> (temp &lt; cost[loop][i-minVal]) <span class="comment">// 找出最小的调整代价</span></div><div class="line">					&#123;</div><div class="line">						cost[loop][i-minVal] = temp;</div><div class="line">						record[loop][i-minVal] = j; <span class="comment">// record中记录的是第loop个数字取i最优时，上一个数字最优时对应的值</span></div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 找出最后一个位置改变结束时最小的改变代价</span></div><div class="line">	<span class="keyword">int</span> minCost = INT_MAX;</div><div class="line">	<span class="keyword">int</span> backtrack; <span class="comment">// 用于回溯之前的一个位置应该调整为哪个数值</span></div><div class="line">	<span class="keyword">for</span> (i = minVal; i &lt;= maxVal; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span> (cost[n][i-minVal] &lt; minCost)</div><div class="line">		&#123;</div><div class="line">			minCost = cost[n][i-minVal];</div><div class="line">			backtrack = i; <span class="comment">// 找到最后一个调整好的数值对应的前一个数值</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="built_in">cout</span> &lt;&lt; minCost &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出最小的调整代价</span></div><div class="line"></div><div class="line">	<span class="keyword">int</span> loc = n - <span class="number">1</span>; <span class="comment">// 对应数组B每个下标</span></div><div class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// 用于核对回溯的每个位置的值是否正确，minCost == sum时正确</span></div><div class="line">	<span class="keyword">while</span> (n &gt; <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		B[loc--] = backtrack;</div><div class="line">		sum += <span class="built_in">abs</span>(A[n<span class="number">-1</span>] - backtrack);</div><div class="line">		backtrack = record[n--][backtrack-minVal]; <span class="comment">// 因为每次找到的调整好的数值，所以索引要调整</span></div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 比较sum是否等于minCost</span></div><div class="line"></div><div class="line">	<span class="comment">// 输出调整之后的数组B</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; A.size(); i++)</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; B[i] &lt;&lt; <span class="string">' '</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>## 2.钢条切割问题<br><br>接下来我们再来看一下《算法导论》上给的一道经典题目，钢条切割问题。<br><br>题目描述：<br><br>一家公司有一根固定长度的钢条，要切割为短的钢条出售。切割工序本身没有成本。公司希望知道最佳的切割方案（即如何切割能够获得价格的最大值）。假设钢条的长度为<code>n</code>（此处假设<code>n &lt;= 10</code>），不同长度<code>i</code>的钢条的价格如下表。<br><table><thead><tr><th style="text-align:center">长度j</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th></tr></thead><thead><tr><th style="text-align:center">价格p</th><th style="text-align:center">1</th><th style="text-align:center">5</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">17</th><th style="text-align:center">17</th><th style="text-align:center">20</th><th style="text-align:center">24</th><th style="text-align:center">30</th></tr></thead></table><br>应用动态规划的思想，我们可以这样考虑问题：假设长度为i时，最佳切割方案时的价格总和为<code>r[i](0 &lt;= i&lt;= n)</code>，那么当长度为<code>i+1</code>时，最佳的方案是<code>r[i+1] = max(p[j] + r[i+1-j]), 1&lt;= j &lt;= i+1</code>。所以状态转移方程即是：<br><center><code>r[i+1] = max(p[j] + r[i+1-j]),1&lt;= j&lt;= i+1</code></center><br>同样，看代码可能思路更清晰：<br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 自底向上实现</span></div><div class="line"><span class="comment">// 数组p记录不同长度的价格，n是所求最大的长度</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cutRodBottomUp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="keyword">const</span> &amp;p, <span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r(n+<span class="number">1</span>, INT_MIN); <span class="comment">// 辅助数组，记录每个长度不同切割方法的最大值。以整型最小值初始化</span></div><div class="line">	r[<span class="number">0</span>] = <span class="number">0</span>; </div><div class="line"></div><div class="line">	<span class="comment">// 动态规划每个长度不同切割方法的最大值</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> q = INT_MIN;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</div><div class="line">		&#123;</div><div class="line">			q = max(q, p[j<span class="number">-1</span>] + r[i-j]);  <span class="comment">// 找到每个长度切割的最大值。上述解释中的j是长度，j-1对应其下标</span></div><div class="line">		&#125;</div><div class="line">		r[i] = q;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> r[n];</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>这时函数返回的是最大的长度，再加一个辅助数组，在每次找出最大价值的时候记录切割位置，就可以找出切割方案了。代码如下：<br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 带有输出分割情况功能的版本</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">cutRodExtended</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="keyword">const</span> &amp;p, <span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r(n+<span class="number">1</span>, INT_MIN); <span class="comment">// 辅助数组，记录每个长度不同切割方法的最大值</span></div><div class="line">	r[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s(n+<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 记录每个长度最大收益时的切割位置</span></div><div class="line">	</div><div class="line">	<span class="keyword">int</span> i, j;</div><div class="line"></div><div class="line">	<span class="comment">// 动态规划步骤</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> q = INT_MIN;</div><div class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i; j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span> (q &lt; p[j<span class="number">-1</span>] + r[i-j])</div><div class="line">			&#123;</div><div class="line">				q = p[j<span class="number">-1</span>] + r[i-j];</div><div class="line">				s[i] = j; <span class="comment">// 记录每个长度最大收益时的切割位置</span></div><div class="line">			&#125;</div><div class="line">			r[i] = q;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="built_in">cout</span> &lt;&lt; r[n] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="comment">// 输出结果</span></div><div class="line">	<span class="keyword">while</span> (n &gt; <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; s[n] &lt;&lt; <span class="string">'\t'</span>;</div><div class="line">		n = n - s[n];</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>这样，就找到最佳切割方案了。<br><br>## 3.最长公共子序列<br><br>最后，再来看另一道《算法导论》里面的经典问题——最长公共子序列，这到题目也非常适合用辅助数组来记录最优解。<br><br>题目描述：<br><br>给定两个序列X = {$x_1$, $x_2$, $x_3$, …, $x_m$ }, 和Y = {$y_1$, $y_2$, …, $y_n$}，求<code>X</code>和<code>Y</code>长度最长的公共子序列。公共子序列的定义为，给定两个序列<code>X</code>，<code>Y</code>，如果<code>Z</code>即是<code>X</code>的子序列，也是<code>Y</code>的子序列，我们称它是<code>X</code>和<code>Y</code>的公共子序列。<br><br>例如：X = {A, B, C, D, A, B}，Y = {B, D, C, B, A}，那么序列｛B, C, A｝就是X和Y的公共子序列，但不是最长公共子序列。X和Y的最长公共子序列是{B, C, A, B}，其长度为4。<br><br>解题思路：<br><br>我们假设Z = {$z_1$, …, $z_k$}是X和Y的一个最长公共子序列。1）如果$x_m$ == $y_n$，那么有$z_k$ == $x_m$ == $y<em>n$，所以$Z\</em>{k-1}$是$X_{m-1}$和$Y_{n-1}$的一个最长公共子序列；2）如果$x_m$ != $y_n$且$x_m$ != $z_k$，那么Z是$X_m-1$和Y的一个最长公共子序列；3）如果$x_m$ != $y_n$且$z_k$ != $y_n$，那么Z是X和$Y_n-1$的一个最长公共子序列。<br><br>我们令<code>c[i][j]</code>表示$X_i$和$Y_j$的最长公共子序列的长度，那么可以得到以下关系：<br><br>情况1:  i==0 或者 j== 0时，<code>c[i][j] = 0</code>；<br>情况2:  i,  j &gt; 0且$x_i$ == $y_j$时， <code>c[i][j] = c[i-1][j-1] + 1</code>;<br>情况3:  i，j &gt; 0且$x_i$ != $y_j$时， <code>c[i][j] = max(c[i][j-1], c[i-1][j])</code>;<br><br>这也就是状态转移方程了。<br><br>同样，给出带有注释的代码可能更好理解，这里第一个版本返回的是最长公共子序列的长度。<br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 自底向上动态规划</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;X, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;Y)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> len1 = X.size();</div><div class="line">	<span class="keyword">int</span> len2 = Y.size();</div><div class="line">	<span class="keyword">int</span> i, j;</div><div class="line"></div><div class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; c(len1+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len2+<span class="number">1</span>)); <span class="comment">// 辅助二维数组，记录$X_i$, $Y_j$的最长公共子序列</span></div><div class="line">	</div><div class="line">	<span class="comment">// 初始化</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= len1; i++)</div><div class="line">		c[i][<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= len2; j++)</div><div class="line">		c[<span class="number">0</span>][j] = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 动态规划过程</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= len1; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= len2; j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span> (X[i<span class="number">-1</span>] == Y[j<span class="number">-1</span>]) <span class="comment">// 对应状态转移方程中情况2</span></div><div class="line">				c[i][j] = c[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (c[i<span class="number">-1</span>][j] &gt; c[i][j<span class="number">-1</span>]) <span class="comment">// 对应状态转移方程中情况3</span></div><div class="line">				c[i][j] = c[i<span class="number">-1</span>][j];</div><div class="line">			<span class="keyword">else</span> <span class="comment">// 对应情况3</span></div><div class="line">				c[i][j] = c[i][j<span class="number">-1</span>];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> c[len1][len2];</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>在情况2和情况3的判断中，可以加入判断结果，将结果记录到一个辅助数组，这样就能回溯结果了，代码如下：<br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 自底向上动态规划。path二维数组记录对应X_i, Y_j的最长公共子序列的选择情况。</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCS2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;X, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;Y,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; &amp;path)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> len1 = X.size();</div><div class="line">	<span class="keyword">int</span> len2 = Y.size();</div><div class="line">	<span class="keyword">int</span> i, j;</div><div class="line"></div><div class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; c(len1+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len2+<span class="number">1</span>)); <span class="comment">// 记录对应位置的结果</span></div><div class="line">	</div><div class="line">	<span class="comment">// 初始化</span></div><div class="line">	path.resize(len1+<span class="number">1</span>);</div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= len1; i++)</div><div class="line">		path[i].resize(len2+<span class="number">1</span>);</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= len1; i++)</div><div class="line">		c[i][<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= len2; j++)</div><div class="line">		c[<span class="number">0</span>][j] = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 动态规划过程</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= len1; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= len2; j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span> (X[i<span class="number">-1</span>] == Y[j<span class="number">-1</span>])</div><div class="line">			&#123;</div><div class="line">				c[i][j] = c[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</div><div class="line">				path[i][j] = <span class="string">"left-top"</span>; <span class="comment">// 上一个位置在左上位置</span></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (c[i<span class="number">-1</span>][j] &gt; c[i][j<span class="number">-1</span>])</div><div class="line">			&#123;</div><div class="line">				c[i][j] = c[i<span class="number">-1</span>][j];</div><div class="line">				path[i][j] = <span class="string">"up"</span>; <span class="comment">// 上一个位置在上方</span></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span></div><div class="line">			&#123;</div><div class="line">				c[i][j] = c[i][j<span class="number">-1</span>];</div><div class="line">				path[i][j] = <span class="string">"left"</span>; <span class="comment">// 上一个位置在左边</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> c[len1][len2];</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>这里配合下图更好理解。<br><img src="http://blog.frankge.me/wp-content/uploads/2016/12/getting-start-to-dynamic-programming-part3-find-the-optimal-solution_001-768x538.png" alt=""><br><br>这里的根据路径输出的函数为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_LCS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;X, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; &amp;path, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span>;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (path[i][j] == <span class="string">"left-top"</span>) <span class="comment">// 左上位置</span></div><div class="line">	&#123;</div><div class="line">		Print_LCS_test(X, path, i<span class="number">-1</span>, j<span class="number">-1</span>);</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; X[i<span class="number">-1</span>];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (path[i][j] == <span class="string">"up"</span>) <span class="comment">// 上方</span></div><div class="line">		Print_LCS_test(X, path, i<span class="number">-1</span>, j);</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (path[i][j] == <span class="string">"left"</span>) <span class="comment">// 左边</span></div><div class="line">		Print_LCS_test(X, path, i, j<span class="number">-1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>参考文献：<br>1.lintcode <a href="http://www.lintcode.com/en/problem/minimum-adjustment-cost/" target="_blank" rel="external">Minimum Adjustment Cost</a>。<br>2.《算法导论（第三版）》，15章，动态规划内容。<br></p>
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://skills.frankge.me/getting-start-to-dynamic-programming-part3-find-the-optimal-solution/" data-id="ciwed2oto0006mgezd4bdx0om" class="article-share-link" data-share="baidu" data-title="浅谈动态规划（三）——找到最优时的解">分享到</a>
      

      
        <a href="http://skills.frankge.me/getting-start-to-dynamic-programming-part3-find-the-optimal-solution/#ds-thread" class="article-comment-link">評論</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/the-way-to-migrate-your-wordpress-website/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">wordpress站点迁移方法</div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <div id="ds-thread" class="ds-thread" data-thread-key="getting-start-to-dynamic-programming-part3-find-the-optimal-solution/" data-title="浅谈动态规划（三）——找到最优时的解" data-url="http://skills.frankge.me/getting-start-to-dynamic-programming-part3-find-the-optimal-solution/"></div>
  </section>
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">歸檔</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分類</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/建站相关/">建站相关</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程学习/">编程学习</a><span class="category-list-count">7</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">標簽</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C/C++</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/我的博客/">我的博客</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深度学习/">深度学习</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情鏈接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://ihuafan.com/" target="_blank">Huafan&#39;s Blog</a>
          </li>
        
          <li>
            <a href="http://heimingx.cn/" target="_blank">Optimize Life - Heiming Xu&#39;s Blog</a>
          </li>
        
          <li>
            <a href="http://zhikaizhang.cn/" target="_blank">Zhikaizhang&#39;s Blog</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Frank. All rights reserved.<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>.
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回頂部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"reqianduan"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
                processEscapes: true
                    
}
  
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
                  
}
    
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Queue(function() {
            var all = MathJax.Hub.getAllJax(), i;
            for(i=0; i < all.length; i += 1) {
                            all[i].SourceElement().parentNode.className += ' has-jax';
                                    
            }
                
        });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<script src="/js/script.js"></script>

</div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
