<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Skills"><title>浅谈动态规划（三）——找到最优时的解 | Frank</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">浅谈动态规划（三）——找到最优时的解</h1><a id="logo" href="/.">Frank</a><p class="description">去探索更大的世界</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Skills</i></a><a href="http://blog.frankge.me"><i class="fa fa-pencil"> Blog</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="http://frankge.me/the-timeline-of-my-site/"><i class="fa fa-history"> Timeline</i></a><a href="http://frankge.me/recommended-blogs/"><i class="fa fa-star-o"> Recommended</i></a><a href="http://frankge.me"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> Rss</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">浅谈动态规划（三）——找到最优时的解</h1><div class="post-meta">Dec 4, 2016<span> | </span><span class="category"><a href="/categories/编程学习/">编程学习</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="getting-start-to-dynamic-programming-part-3-find-the-optimal-solution/" href="/getting-start-to-dynamic-programming-part-3-find-the-optimal-solution/#comments" class="ds-thread-count"></a><div class="post-content"><p>前两次动态规划的博客中，介绍了动态规划最基础的两个特点以及列举了几个我在做lintcode中遇到的接触动态规划初期相对比较适合做的题目。这次结合几道题目来总结一下动态规划的另一个特点——找到最优时的解。</p>
<p>同样，还是以题目来说明。</p>
<h2 id="1-Minimum-Adjustment-Cost"><a href="#1-Minimum-Adjustment-Cost" class="headerlink" title="1.Minimum Adjustment Cost"></a>1.<span style="color: #3366ff;"><a href="http://www.lintcode.com/en/problem/minimum-adjustment-cost/" target="_blank" rel="external">Minimum Adjustment Cost</a></span></h2><p>题目描述：<br>Given an integer array, adjust each integers so that the difference of every adjacent integers are not greater than a given number target.If the array before adjustment is <code>A</code>, the array after adjustment is <code>B</code>, you should minimize the sum of <code>|A[i]-B[i]|</code></p>
<p>Notice: You can assume each number in the array is a positive integer and not greater than <code>100</code>.</p>
<p>Example: Given <code>[1,4,2,3]</code> and <code>target = 1</code>, one of the solutions is <code>[2,3,2,3]</code>, the adjustment cost is <code>2</code> and it’s minimal.</p>
<p>题目给出了一个数组<code>A</code>，并且给出了一个目标数字<code>target</code>。要求调整数组中每个位置的数字得到数组B，使得数组B中相邻元素的差值的绝对值小于等于<code>target</code>，且$sum(|A[i] - B[i]|)$最小。求得到最终结果时每个位置调整的和最小为多少。</p>
<p>题目只要求找出最小的调整开销的和，我这里再加一问：在调整和为最小值时，找出一个可能的数组<code>B</code>。</p>
<p>先来解决lintcode要求的问题。</p>
<p>Minimum Adjustment Cost题解:</p>
<p>我们应该能够想通一个问题，调整后的每个位置的数字都是在A数组中出现的最小值与最大值之间的数字。假设最小值是<code>minVal</code>，最大值是<code>maxVal</code>，所以数组B的每个位置上可选择的数字的个数为$count = maxVal - minVal + 1$。</p>
<p>构造一个二维数组$cost[n+1][count]$，<code>n</code>表示数组<code>A</code>中的个数。$cost[loop][j]$$(0 &lt;= loop &lt;= n, minVal &lt;= j &lt;= maxVal)$表示<code>B</code>数组中第<code>loop</code>个位置上（此时<code>B</code>的下标为<code>loop-1</code>）调整为数字j时的调整总和（包括<code>loop</code>之前的所有位置的调整的和）。那么当调整下一个位置<code>loop+1</code>时，调整为数字i的调整总和为$cost[loop+1][i] = min(cost[loop][j] + | i - A[loop] |)$,$|i - j| &lt;= target$。这里<code>j</code>是上一个位置时调整的结果，因为有限制条件相邻的两个元素差的绝对值小于<code>target</code>，所以要用到上一个位置的数组；<code>|i - A[i]|</code>是此位置（数组<code>B</code>中第<code>loop+1</code>个数字，下标为<code>loop</code>）调整为i时调整的代价。最后的结果是$cost[n][i]$$(minVal &lt;= i &lt;= maxVal)$中最小的值。</p>
<p>可能我的表述不太清楚，加注释的代码可能表达的更清楚些：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinAdjustmentCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> target)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n = A.size();</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span> || n == <span class="number">1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> minVal = INT_MAX; <span class="comment">// 记录数组中最小值</span></div><div class="line">	<span class="keyword">int</span> maxVal = INT_MIN; <span class="comment">// 记录数组中最大值</span></div><div class="line">			</div><div class="line">	<span class="keyword">int</span> loop, i, j;</div><div class="line">	</div><div class="line">	<span class="comment">// 找出数组A中出现的最小值和最大值</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span> (A[i] &gt; maxVal)</div><div class="line">			maxVal = A[i];</div><div class="line">		<span class="keyword">if</span> (A[i] &lt; minVal)</div><div class="line">			minVal = A[i];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">int</span> count = maxVal - minVal + <span class="number">1</span>; <span class="comment">// 每次需要动态规划的个数</span></div><div class="line">	<span class="comment">// 辅助数组。记录每个位置上B调整为不同数字的最小开销。</span></div><div class="line">	<span class="comment">// 即，当B数组第loop个数字调整为i的时候的最小开销为cost[loop][i]</span></div><div class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; cost(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(count, INT_MAX)); </div><div class="line">	<span class="comment">// 初始化</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</div><div class="line">		cost[<span class="number">0</span>][i] = <span class="number">0</span>; </div><div class="line"></div><div class="line">	<span class="comment">// 动态规划步骤</span></div><div class="line">	<span class="keyword">for</span> (loop = <span class="number">1</span>; loop &lt;= n; loop++)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">// 找出数组B中，第loop个位置（下标为loop-1），选择数字i的最小调整代价</span></div><div class="line">		<span class="comment">// 即，找出cost[loop][i]。它记录了到loop位置时，调整为i数字的最小开销</span></div><div class="line">		<span class="keyword">for</span> (i = minVal; i &lt;= maxVal; i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">for</span> (j = minVal; j &lt;= maxVal; j++)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span> (<span class="built_in">abs</span>(i-j) &lt;= target)</div><div class="line">				&#123;</div><div class="line">					<span class="keyword">int</span> temp = cost[loop<span class="number">-1</span>][j-minVal] + <span class="built_in">abs</span>(i-A[loop<span class="number">-1</span>]); <span class="comment">// 当第loop-1个数字选择j时，第loop个数字选择（调整到）i时的改变量</span></div><div class="line">					<span class="keyword">if</span> (temp &lt; cost[loop][i-minVal]) <span class="comment">// 找出最小的调整代价</span></div><div class="line">						cost[loop][i-minVal] = temp;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 找出最后一个位置改变结束时最小的改变代价</span></div><div class="line">	<span class="keyword">int</span> minCost = INT_MAX;</div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</div><div class="line">		minCost = min(cost[n][i], minCost);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> minCost;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们发现，在每次比较找出最小开销的时候，可以在加一个辅助数组$record[n+1][count]$,记录每个位置时最小调整开销时选择的数字，最后得到了完整的cost列表之后，$cost[n][i]（minVal &lt;= i &lt;= maxVal）$中最小时i的值就是<code>B[n-1]</code>中的值，然后$record[n][i]$中记录的即使上一个位置对应的<code>B</code>中的值，一次类推，便能找到<code>B</code>数组一个可能的结果。同样，看代码可能更清楚点:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实现了记录每次选择数字的功能</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MinAdjustmentCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> target)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n = A.size();</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span> || n == <span class="number">1</span>)</div><div class="line">		<span class="keyword">return</span>;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> minVal = INT_MAX; <span class="comment">// 记录数组中最小值</span></div><div class="line">	<span class="keyword">int</span> maxVal = INT_MIN; <span class="comment">// 记录数组中最大值</span></div><div class="line">			</div><div class="line">	<span class="keyword">int</span> loop, i, j;</div><div class="line">			</div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span> (A[i] &gt; maxVal)</div><div class="line">			maxVal = A[i];</div><div class="line">		<span class="keyword">if</span> (A[i] &lt; minVal)</div><div class="line">			minVal = A[i];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">int</span> count = maxVal - minVal + <span class="number">1</span>; <span class="comment">// 每次需要动态规划的个数</span></div><div class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; cost(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(count, INT_MAX)); <span class="comment">// 辅助数组</span></div><div class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; record(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(count, <span class="number">0</span>));</div><div class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B(n);</div><div class="line">	<span class="comment">// 初始化</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</div><div class="line">		cost[<span class="number">0</span>][i] = <span class="number">0</span>; </div><div class="line"></div><div class="line">	<span class="comment">// 动态规划步骤</span></div><div class="line">	<span class="keyword">for</span> (loop = <span class="number">1</span>; loop &lt;= n; loop++)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">// 找出第loop个位置，选择数字i的最小调整代价</span></div><div class="line">		<span class="keyword">for</span> (i = minVal; i &lt;= maxVal; i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">for</span> (j = minVal; j &lt;= maxVal; j++)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span> (<span class="built_in">abs</span>(i-j) &lt;= target)</div><div class="line">				&#123;</div><div class="line">					<span class="keyword">int</span> temp = cost[loop<span class="number">-1</span>][j-minVal] + <span class="built_in">abs</span>(i-A[loop<span class="number">-1</span>]); <span class="comment">// 当第loop-1个数字选择j时，第loop个数字选择（调整到）i时的改变量</span></div><div class="line">					<span class="keyword">if</span> (temp &lt; cost[loop][i-minVal]) <span class="comment">// 找出最小的调整代价</span></div><div class="line">					&#123;</div><div class="line">						cost[loop][i-minVal] = temp;</div><div class="line">						record[loop][i-minVal] = j; <span class="comment">// record中记录的是第loop个数字取i最优时，上一个数字最优时对应的值</span></div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 找出最后一个位置改变结束时最小的改变代价</span></div><div class="line">	<span class="keyword">int</span> minCost = INT_MAX;</div><div class="line">	<span class="keyword">int</span> backtrack; <span class="comment">// 用于回溯之前的一个位置应该调整为哪个数值</span></div><div class="line">	<span class="keyword">for</span> (i = minVal; i &lt;= maxVal; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span> (cost[n][i-minVal] &lt; minCost)</div><div class="line">		&#123;</div><div class="line">			minCost = cost[n][i-minVal];</div><div class="line">			backtrack = i; <span class="comment">// 找到最后一个调整好的数值对应的前一个数值</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="built_in">cout</span> &lt;&lt; minCost &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出最小的调整代价</span></div><div class="line"></div><div class="line">	<span class="keyword">int</span> loc = n - <span class="number">1</span>; <span class="comment">// 对应数组B每个下标</span></div><div class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// 用于核对回溯的每个位置的值是否正确，minCost == sum时正确</span></div><div class="line">	<span class="keyword">while</span> (n &gt; <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		B[loc--] = backtrack;</div><div class="line">		sum += <span class="built_in">abs</span>(A[n<span class="number">-1</span>] - backtrack);</div><div class="line">		backtrack = record[n--][backtrack-minVal]; <span class="comment">// 因为每次找到的调整好的数值，所以索引要调整</span></div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 比较sum是否等于minCost</span></div><div class="line"></div><div class="line">	<span class="comment">// 输出调整之后的数组B</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; A.size(); i++)</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; B[i] &lt;&lt; <span class="string">' '</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="2-钢条切割问题"><a href="#2-钢条切割问题" class="headerlink" title="2.钢条切割问题"></a>2.钢条切割问题</h2><p>接下来我们再来看一下《算法导论》上给的一道经典题目，钢条切割问题。</p>
<p>题目描述：</p>
<p>一家公司有一根固定长度的钢条，要切割为短的钢条出售。切割工序本身没有成本。公司希望知道最佳的切割方案（即如何切割能够获得价格的最大值）。假设钢条的长度为<code>n</code>（此处假设<code>n &lt;= 10</code>），不同长度<code>i</code>的钢条的价格如下表。</p>
<p><table><thead><tr><th style="text-align:center">长度j</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th></tr></thead><thead><tr><th style="text-align:center">价格p</th><th style="text-align:center">1</th><th style="text-align:center">5</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">17</th><th style="text-align:center">17</th><th style="text-align:center">20</th><th style="text-align:center">24</th><th style="text-align:center">30</th></tr></thead></table><br>应用动态规划的思想，我们可以这样考虑问题：假设长度为i时，最佳切割方案时的价格总和为$r[i]$$(0 &lt;= i&lt;= n)$，那么当长度为<code>i+1</code>时，最佳的方案是$r[i+1] = max(p[j] + r[i+1-j]), 1&lt;= j &lt;= i+1$。所以状态转移方程即是：</p>
<p><center>$r[i+1] = max(p[j] + r[i+1-j]),1&lt;= j&lt;= i+1$</center><br>同样，看代码可能思路更清晰：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 自底向上实现</span></div><div class="line"><span class="comment">// 数组p记录不同长度的价格，n是所求最大的长度</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cutRodBottomUp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="keyword">const</span> &amp;p, <span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r(n+<span class="number">1</span>, INT_MIN); <span class="comment">// 辅助数组，记录每个长度不同切割方法的最大值。以整型最小值初始化</span></div><div class="line">	r[<span class="number">0</span>] = <span class="number">0</span>; </div><div class="line"></div><div class="line">	<span class="comment">// 动态规划每个长度不同切割方法的最大值</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> q = INT_MIN;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</div><div class="line">		&#123;</div><div class="line">			q = max(q, p[j<span class="number">-1</span>] + r[i-j]);  <span class="comment">// 找到每个长度切割的最大值。上述解释中的j是长度，j-1对应其下标</span></div><div class="line">		&#125;</div><div class="line">		r[i] = q;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> r[n];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这时函数返回的是最大的长度，再加一个辅助数组，在每次找出最大价值的时候记录切割位置，就可以找出切割方案了。代码如下：<br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 带有输出分割情况功能的版本</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">cutRodExtended</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="keyword">const</span> &amp;p, <span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r(n+<span class="number">1</span>, INT_MIN); <span class="comment">// 辅助数组，记录每个长度不同切割方法的最大值</span></div><div class="line">	r[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s(n+<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 记录每个长度最大收益时的切割位置</span></div><div class="line">	</div><div class="line">	<span class="keyword">int</span> i, j;</div><div class="line"></div><div class="line">	<span class="comment">// 动态规划步骤</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> q = INT_MIN;</div><div class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i; j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span> (q &lt; p[j<span class="number">-1</span>] + r[i-j])</div><div class="line">			&#123;</div><div class="line">				q = p[j<span class="number">-1</span>] + r[i-j];</div><div class="line">				s[i] = j; <span class="comment">// 记录每个长度最大收益时的切割位置</span></div><div class="line">			&#125;</div><div class="line">			r[i] = q;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="built_in">cout</span> &lt;&lt; r[n] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="comment">// 输出结果</span></div><div class="line">	<span class="keyword">while</span> (n &gt; <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; s[n] &lt;&lt; <span class="string">'\t'</span>;</div><div class="line">		n = n - s[n];</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，就找到最佳切割方案了。</p>
<h2 id="3-最长公共子序列"><a href="#3-最长公共子序列" class="headerlink" title="3.最长公共子序列"></a>3.最长公共子序列</h2><p>最后，再来看另一道《算法导论》里面的经典问题——最长公共子序列，这到题目也非常适合用辅助数组来记录最优解。</p>
<p>题目描述：</p>
<p>给定两个序列X = {$x_1$, $x_2$, $x_3$, …, $x_m$ }, 和Y = {$y_1$, $y_2$, …, $y_n$}，求<code>X</code>和<code>Y</code>长度最长的公共子序列。公共子序列的定义为，给定两个序列<code>X</code>，<code>Y</code>，如果<code>Z</code>即是<code>X</code>的子序列，也是<code>Y</code>的子序列，我们称它是<code>X</code>和<code>Y</code>的公共子序列。</p>
<p>例如：X = {A, B, C, D, A, B}，Y = {B, D, C, B, A}，那么序列｛B, C, A｝就是X和Y的公共子序列，但不是最长公共子序列。X和Y的最长公共子序列是{B, C, A, B}，其长度为4。</p>
<p>解题思路：</p>
<p>我们假设Z = {$z_1$, …, $z_k$}是X和Y的一个最长公共子序列。1）如果$x_m$ == $y_n$，那么有$z_k$ == $x_m$ == $y_n$，所以$Z_{k-1}$是$X_{m-1}$和$Y_{n-1}$的一个最长公共子序列；2）如果$x_m$ != $y_n$且$x_m$ != $z_k$，那么Z是$X_{m-1}$和Y的一个最长公共子序列；3）如果$x_m$ != $y_n$且$z_k$ != $y_n$，那么Z是X和$Y_{n-1}$的一个最长公共子序列。</p>
<p>我们令$c[i][j]$表示$X_i$和$Y_j$的最长公共子序列的长度，那么可以得到以下关系：</p>
<p>情况1:  $i==0$ 或者 $j== 0$时，$[i][j] = 0$;<br>情况2:  $i,  j &gt; 0$且$x_i$ == $y_j$时， $c[i][j] = c[i-1][j-1] + 1$;<br>情况3:  $i，j &gt; 0$且$x_i$ != $y_j$时， $c[i][j] = max(c[i][j-1], c[i-1][j])$;</p>
<p>这也就是状态转移方程了。</p>
<p>同样，给出带有注释的代码可能更好理解，这里第一个版本返回的是最长公共子序列的长度。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 自底向上动态规划</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;X, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;Y)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> len1 = X.size();</div><div class="line">	<span class="keyword">int</span> len2 = Y.size();</div><div class="line">	<span class="keyword">int</span> i, j;</div><div class="line"></div><div class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; c(len1+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len2+<span class="number">1</span>)); <span class="comment">// 辅助二维数组，记录$X_i$, $Y_j$的最长公共子序列</span></div><div class="line">	</div><div class="line">	<span class="comment">// 初始化</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= len1; i++)</div><div class="line">		c[i][<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= len2; j++)</div><div class="line">		c[<span class="number">0</span>][j] = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 动态规划过程</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= len1; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= len2; j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span> (X[i<span class="number">-1</span>] == Y[j<span class="number">-1</span>]) <span class="comment">// 对应状态转移方程中情况2</span></div><div class="line">				c[i][j] = c[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (c[i<span class="number">-1</span>][j] &gt; c[i][j<span class="number">-1</span>]) <span class="comment">// 对应状态转移方程中情况3</span></div><div class="line">				c[i][j] = c[i<span class="number">-1</span>][j];</div><div class="line">			<span class="keyword">else</span> <span class="comment">// 对应情况3</span></div><div class="line">				c[i][j] = c[i][j<span class="number">-1</span>];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> c[len1][len2];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在情况2和情况3的判断中，可以加入判断结果，将结果记录到一个辅助数组，这样就能回溯结果了，代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 自底向上动态规划。path二维数组记录对应X_i, Y_j的最长公共子序列的选择情况。</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCS2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;X, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;Y,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; &amp;path)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> len1 = X.size();</div><div class="line">	<span class="keyword">int</span> len2 = Y.size();</div><div class="line">	<span class="keyword">int</span> i, j;</div><div class="line"></div><div class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; c(len1+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len2+<span class="number">1</span>)); <span class="comment">// 记录对应位置的结果</span></div><div class="line">	</div><div class="line">	<span class="comment">// 初始化</span></div><div class="line">	path.resize(len1+<span class="number">1</span>);</div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= len1; i++)</div><div class="line">		path[i].resize(len2+<span class="number">1</span>);</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= len1; i++)</div><div class="line">		c[i][<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= len2; j++)</div><div class="line">		c[<span class="number">0</span>][j] = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 动态规划过程</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= len1; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= len2; j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span> (X[i<span class="number">-1</span>] == Y[j<span class="number">-1</span>])</div><div class="line">			&#123;</div><div class="line">				c[i][j] = c[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</div><div class="line">				path[i][j] = <span class="string">"left-top"</span>; <span class="comment">// 上一个位置在左上位置</span></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (c[i<span class="number">-1</span>][j] &gt; c[i][j<span class="number">-1</span>])</div><div class="line">			&#123;</div><div class="line">				c[i][j] = c[i<span class="number">-1</span>][j];</div><div class="line">				path[i][j] = <span class="string">"up"</span>; <span class="comment">// 上一个位置在上方</span></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span></div><div class="line">			&#123;</div><div class="line">				c[i][j] = c[i][j<span class="number">-1</span>];</div><div class="line">				path[i][j] = <span class="string">"left"</span>; <span class="comment">// 上一个位置在左边</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> c[len1][len2];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里配合下图更好理解。<br><img src="http://blog.frankge.me/wp-content/uploads/2016/12/getting-start-to-dynamic-programming-part3-find-the-optimal-solution_001-768x538.png" alt=""></p>
<p>这里的根据路径输出的函数为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_LCS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;X, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; &amp;path, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span>;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (path[i][j] == <span class="string">"left-top"</span>) <span class="comment">// 左上位置</span></div><div class="line">	&#123;</div><div class="line">		Print_LCS_test(X, path, i<span class="number">-1</span>, j<span class="number">-1</span>);</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; X[i<span class="number">-1</span>];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (path[i][j] == <span class="string">"up"</span>) <span class="comment">// 上方</span></div><div class="line">		Print_LCS_test(X, path, i<span class="number">-1</span>, j);</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (path[i][j] == <span class="string">"left"</span>) <span class="comment">// 左边</span></div><div class="line">		Print_LCS_test(X, path, i, j<span class="number">-1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>参考文献：<br>1.lintcode <a href="http://www.lintcode.com/en/problem/minimum-adjustment-cost/" target="_blank" rel="external">Minimum Adjustment Cost</a>。<br>2.《算法导论（第三版）》，15章，动态规划内容。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://skills.frankge.me/getting-start-to-dynamic-programming-part-3-find-the-optimal-solution/" data-id="cixsxfycl0006y0ezpdjm1t09" class="article-share-link">分享到</a><div class="tags"><a href="/tags/算法/">算法</a></div><div class="post-nav"><a href="/getting-start-to-dynamic-programming-part-4-using-recursion-in-a-smart-way/" class="pre">浅谈动态规划（四）——巧用递归</a><a href="/the-way-to-migrate-your-wordpress-website/" class="next">wordpress站点迁移方法</a></div><div data-thread-key="getting-start-to-dynamic-programming-part-3-find-the-optimal-solution/" data-title="浅谈动态规划（三）——找到最优时的解" data-url="http://skills.frankge.me/getting-start-to-dynamic-programming-part-3-find-the-optimal-solution/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="getting-start-to-dynamic-programming-part-3-find-the-optimal-solution/" data-title="浅谈动态规划（三）——找到最优时的解" data-url="http://skills.frankge.me/getting-start-to-dynamic-programming-part-3-find-the-optimal-solution/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://skills.frankge.me"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/建站相关/">建站相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程学习/">编程学习</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-tags"> 标签</i></div><div class="tagcloud"><a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/深度学习/" style="font-size: 15px;">深度学习</a> <a href="/tags/我的博客/" style="font-size: 15px;">我的博客</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://ihuafan.com/" title="Huafan's Blog" target="_blank">Huafan's Blog</a><ul></ul><a href="http://heimingx.cn/" title="Optimize Life - Heiming Xu's Blog" target="_blank">Optimize Life - Heiming Xu's Blog</a><ul></ul><a href="http://zhikaizhang.cn/" title="Zhikaizhang's Blog" target="_blank">Zhikaizhang's Blog</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer"> Copyright &copy; 2016-2017 <a href="http://skills.frankge.me/">Frank</a>.
 Powered by <a href="https://hexo.io">Hexo</a>.</div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'skillsfrankge'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>